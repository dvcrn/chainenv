package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/dvcrn/chainenv/config"
	"github.com/spf13/cobra"
)

var (
	generateEnvStdout bool
	generateEnvForce  bool
)

var generateEnvCmd = &cobra.Command{
	Use:   "generate-env",
	Short: "Generate a .envrc file from config",
	Long:  "Generate a .envrc file that exports keys declared in the chainenv config.",
	Run: func(cmd *cobra.Command, args []string) {
		cfg, err := loadConfig()
		if err != nil {
			log.Err("Error loading config: %v", err)
			os.Exit(1)
		}
		if cfg == nil {
			fmt.Fprintln(os.Stderr, "No config found")
			os.Exit(1)
		}
		if len(cfg.Keys) == 0 {
			fmt.Fprintln(os.Stderr, "No keys found")
			return
		}

		content := buildEnvrc(cfg.Keys)
		if generateEnvStdout {
			fmt.Print(content)
			return
		}

		cwd, err := os.Getwd()
		if err != nil {
			log.Err("Failed to determine current directory: %v", err)
			os.Exit(1)
		}
		path := filepath.Join(cwd, ".envrc")
		if !generateEnvForce {
			if _, err := os.Stat(path); err == nil {
				fmt.Fprintln(os.Stderr, ".envrc already exists (use --force to overwrite)")
				os.Exit(1)
			} else if !os.IsNotExist(err) {
				log.Err("Failed to stat .envrc: %v", err)
				os.Exit(1)
			}
		}

		if err := writeFileAtomic(path, []byte(content), 0o644); err != nil {
			log.Err("Failed to write .envrc: %v", err)
			os.Exit(1)
		}
	},
}

func init() {
	generateEnvCmd.Flags().BoolVar(&generateEnvStdout, "stdout", false, "Write the .envrc contents to stdout")
	generateEnvCmd.Flags().BoolVar(&generateEnvForce, "force", false, "Overwrite .envrc if it already exists")
	rootCmd.AddCommand(generateEnvCmd)
}

func buildEnvrc(keys []config.KeyEntry) string {
	var builder strings.Builder
	builder.WriteString("# Generated by chainenv\n")
	for _, entry := range keys {
		if entry.Name == "" {
			continue
		}
		builder.WriteString(fmt.Sprintf("export %s=\"$(chainenv get %s)\"\n", entry.Name, entry.Name))
	}
	return builder.String()
}

func writeFileAtomic(path string, data []byte, perm os.FileMode) error {
	if len(data) > 0 && data[len(data)-1] != '\n' {
		data = append(data, '\n')
	}

	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}

	tmp, err := os.CreateTemp(dir, filepath.Base(path)+".tmp-*")
	if err != nil {
		return err
	}
	defer os.Remove(tmp.Name())

	if _, err := tmp.Write(data); err != nil {
		tmp.Close()
		return err
	}
	if err := tmp.Close(); err != nil {
		return err
	}
	if err := os.Chmod(tmp.Name(), perm); err != nil {
		return err
	}

	return os.Rename(tmp.Name(), path)
}
